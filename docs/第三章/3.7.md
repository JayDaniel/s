
## 状态管理
在 React Native 要做状态管理通常都是使用 Redux，这种方式非常好。幸运的是，在 Flutter 也支持使用 Redux。

flutter_redux 是一个支持在 Flutter 里使用 Redux 的库，但并不是使用 JS 版本的 Redux，而是使用 dart_redux，这是一个在 dart 上的 Redux 实现。

Redux 的基础知识就不多说了，在这里主要介绍如何在 Flutter 里使用 Redux 管理应用的数据状态。

先安装依赖：

```js
dependencies:
  redux: ^3.0.0
  flutter_redux: ^0.5.2
```

在 Flutter Redux 里有一个必要知道的概念：
- `StoreProvider` - 一个组件，它会将给定的 Redux Store 传递给它的所有子组件。
- `StoreBuilder` - 一个子 Widget 组件，StoreProvider 它从 Action 中获取 Store 并将其传递给 Widget builder 函数。
- `StoreConnector` - 从最近的 StoreProvider 祖先获取 Store 的子 Widget，使用给定的函数将其转换 Store 为 Action，并将其传递给函数。只要 Store 发出更改事件，Widget 就会自动重建。无需管理订阅！

下面来看一个简单的示例。

```js
import 'package:flutter/material.dart';
import 'package:redux/redux.dart';
import 'package:flutter_redux/flutter_redux.dart';

void main() {
    runApp(new FlutterReduxApp());
}

// 定义个 Types 枚举
enum Types { Increment }

// Reducer 处理
int counterReducer(int state, action) {
    if (action == Types.Increment) {
        return state + 1;
    }

    return state;
}

// 创建一个 Action 类
class Action {
    dynamic _store;
    Action(store) {
        this._store = store;
    }

    // 某个 Action
    increment() {
        this._store.dispatch(Types.Increment);
    }
}

class FlutterReduxApp extends StatelessWidget {
    // 创建一个 store
    final store = new Store(counterReducer, initialState: 0);

    @override
    Widget build(BuildContext context) {
        final action = new Action(store);

        return new MaterialApp(
            theme: new ThemeData.light(),
            // 创建一个 Provider
            home: new StoreProvider(
                store: this.store,
                child: new Scaffold(
                    body: new Center(
                        child: new Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                            new Text('You have pushed the button this many times:'),
                            // 连接器，连接之后可以获取数据，在 builder 里渲染内容
                            new StoreConnector<int, String>(
                                converter: (store) => store.state.toString(),
                                builder: (context, count) => new Text(count),
                            )
                        ],
                        ),
                    ),
                    floatingActionButton: new FloatingActionButton(
                        onPressed: action.increment, // action
                        child: new Icon(Icons.add),
                    ),
                ),
            ),
        );
    }
}
```

在需要改变状态的组件里使用 StoreConnector 连接数据（避免对整个内容做一次性的连接，导致整个渲染）。

在这里 Store 是一个泛型类，在初始化时请给它一个类型，否则就是 `Store<int>`。很多时候 State 是一个复杂的结构，并不是一个简单的 int 类型，那么如何适配？

```js
// Reducer 处理
MyState counterReducer(MyState state, action) {
    if (action == Types.Increment) {
        state.count++;
        return state.newState(state);
    }

    return state;
}

class MyState {
    List<String> list;
    String name;
    int count;
    MyState(this.list, this.name, this.count);
    newState(MyState obj) {
        this.name = obj.name;
        this.list = obj.list;
        this.count = obj.count;
        return new MyState(obj.list, obj.name, obj.count);
    }
}

// 创建一个 store
final store = new Store<MyState>(counterReducer, initialState: new MyState([], 'abc', 0));

// 连接器，连接之后可以获取数据，在 builder 里渲染内容
new StoreConnector<MyState, String>(
    converter: (store) => store.state.count.toString(),
    builder: (context, count) => new Text(count),
),
```

StoreConnector 里的 converter 一定要是返回 String 吗？目前为止是的，因为大多数的在 Widget 上都是使用字符串渲染。
